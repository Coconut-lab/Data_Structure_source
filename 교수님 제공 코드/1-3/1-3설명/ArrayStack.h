// 두근두근 자료구조 개정판(최영규, 생능 출판사)
// 참고파일 ch03/ArrayStack.h

//-------------------------------------------------------------
// 코드 3.1 배열을 이용한 스택의 구현
//-------------------------------------------------------------
/*
 * [스택(Stack) 자료구조 개념]
 * 스택은 후입선출(LIFO: Last-In-First-Out) 원칙을 따르는 자료구조입니다.
 * 마치 접시를 쌓아 올리는 것처럼, 가장 나중에 넣은 데이터가 가장 먼저 꺼내집니다.
 * 주요 연산: push(삽입), pop(삭제), peek(참조)
 * 
 * [배열 기반 구현의 특징]
 * - 장점: 구현이 간단하고 접근 속도가 빠름
 * - 단점: 크기가 고정되어 있어 오버플로우 가능성 있음
 */

#ifndef _ARRAY_STACK_
#define _ARRAY_STACK_

#include <stdio.h>
#include <stdlib.h> // exit() 함수를 위한 헤더 추가

// 스택의 데이터(Element와 MAX_SIZE는 미리 정의되어 있어야 함)
/*
 * [전처리 요구사항]
 * 이 헤더를 사용하기 전에 반드시 다음 두 가지를 정의해야 합니다:
 * 1. typedef 문으로 Element 타입 정의 (예: typedef int Element;)
 * 2. #define으로 MAX_SIZE 정의 (예: #define MAX_SIZE 100)
 * 
 * 이런 설계는 스택에 저장될 데이터 타입과 최대 크기를 유연하게 변경할 수 있게 합니다.
 */
Element data[MAX_SIZE]; // 스택 요소의 배열
int top;               // 스택 상단 인덱스 (스택의 맨 위 요소를 가리킴)

// 오류 처리 함수
void error(char* str) {
    printf("%s\n", str);
    exit(1);  // 프로그램 강제 종료
}

//-------------------------------------------------------------
// 스택의 주요 연산들
//-------------------------------------------------------------

// 스택 초기화
void init_stack() {
    top = -1;  // top을 -1로 설정하여 빈 스택 표시
    /*
     * [중요] 스택이 비어있을 때 top이 -1인 이유:
     * 1. 배열은 0부터 시작하므로, -1은 "유효한 데이터 없음"을 의미
     * 2. push 연산에서 먼저 top을 증가시킨 후(++top) 데이터를 저장하므로,
     *    첫 요소는 인덱스 0에 저장됨
     * 3. 스택의 크기를 top+1로 계산할 때 직관적임
     */
}

// 스택이 비어있는지 확인
int is_empty() {
    if (top == -1) 
        return 1;  // 참(1)을 반환하여 스택이 비어있음을 나타냄
    else 
        return 0;  // 거짓(0)을 반환하여 스택에 요소가 있음을 나타냄
}

// 스택이 가득 찼는지 확인
int is_full() {
    return (top == (MAX_SIZE - 1));  // 스택의 top이 배열의 마지막 인덱스에 있으면 가득 찬 상태
    // MAX_SIZE가 100이면, 인덱스는 0~99까지이므로 top이 99일 때 가득 참
}

// 스택에 요소 추가 (push 연산)
void push(Element e) {
    if (is_full())
        error("Overflow Error!");  // 스택이 가득 찼을 때 오류 처리
    else 
        data[++top] = e;  // 먼저 top을 증가시킨 후 데이터 저장
        /*
         * [참고] ++top vs top++
         * ++top: 먼저 top을 증가시킨 후 사용 (전위 증가)
         * top++: 현재 top 값을 사용한 후 증가 (후위 증가)
         * 여기서는 먼저 증가시켜야 올바른 위치에 저장됨
         */
}

// 스택에서 요소 제거 및 반환 (pop 연산)
Element pop() {
    if (is_empty())
        error("Underflow Error!");  // 스택이 비어있을 때 오류 처리
    return data[top--];  // 현재 top 위치의 데이터를 반환하고 top 감소
    // top--: 현재 top 값을 사용한 후 감소 (후위 감소)
}

// 스택의 최상위 요소 반환 (제거하지 않음) (peek 연산)
Element peek() {
    if (is_empty())
        error("Underflow Error!");  // 스택이 비어있을 때 오류 처리
    return data[top];  // 현재 top 위치의 데이터만 반환 (top 값 변경 없음)
    // pop과 달리 스택의 상태를 변경하지 않고 단순 조회만 함
}

// 스택의 현재 크기 반환
int size() {
    return top + 1;  // top은 0부터 시작하므로 크기는 top+1
    // top이 -1이면 크기는 0, top이 0이면 크기는 1
}

#endif