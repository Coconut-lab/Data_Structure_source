// 명품 열혈 C자료구조(최영규, 생능 출판사, 2024)
// 참고파일: ch03/HanoiTower.c

//-------------------------------------------------------------
// 코드 3.10 하노이의 탑
//-------------------------------------------------------------
/*
 * [하노이의 탑 문제 설명]
 * 하노이의 탑은 세 개의 기둥(A, B, C)과 크기가 다른 n개의 원반으로 구성됩니다.
 * 처음에는 모든 원반이 A 기둥에 크기 순서대로 쌓여 있습니다.
 * 
 * [규칙]
 * 1. 한 번에 하나의 원반만 이동할 수 있습니다.
 * 2. 큰 원반이 작은 원반 위에 놓일 수 없습니다.
 * 3. 세 개의 기둥 중 어느 기둥이든 사용할 수 있습니다.
 * 
 * [목표]
 * 모든 원반을 A 기둥에서 C 기둥으로 옮기는 것입니다.
 * 
 * [재귀적 해결 방법]
 * 1. n-1개의 원반을 A에서 B로 옮깁니다 (C를 임시 기둥으로 사용).
 * 2. 가장 큰 원반(n번째)을 A에서 C로 옮깁니다.
 * 3. n-1개의 원반을 B에서 C로 옮깁니다 (A를 임시 기둥으로 사용).
 */
#include <stdio.h>

/*
 * [함수: hanoi_tower]
 * 매개변수: 
 *   int n - 원반의 개수
 *   char from - 출발 기둥
 *   char tmp - 임시 기둥
 *   char to - 목적지 기둥
 * 기능: n개의 원반을 출발 기둥에서 목적지 기둥으로 옮기는 과정을 출력
 * 
 * [재귀 알고리즘 분석]
 * 1. 기저 조건(Base case): n == 1일 때 (원반 하나만 있으면 직접 옮김)
 * 2. 재귀 호출 1: n-1개 원반을 from에서 tmp로 이동 (to를 임시로 사용)
 * 3. 직접 이동: n번째(가장 큰) 원반을 from에서 to로 이동
 * 4. 재귀 호출 2: n-1개 원반을 tmp에서 to로 이동 (from을 임시로 사용)
 */
void hanoi_tower(int n, char from, char tmp, char to)
{
    if (n == 1)  // 기저 조건: 원반이 1개면 바로 이동
        printf("원판 1: %c --> %c\n", from, to);
    else {
        // 단계 1: n-1개의 원반을 from에서 tmp로 이동 (to를 임시로 사용)
        hanoi_tower(n - 1, from, to, tmp);
        
        // 단계 2: n번 원반(가장 큰 원반)을 from에서 to로 이동
        printf("원판 %d: %c --> %c\n", n, from, to);
        
        // 단계 3: n-1개의 원반을 tmp에서 to로 이동 (from을 임시로 사용)
        hanoi_tower(n - 1, tmp, from, to);
    }
}

void main() {
    hanoi_tower(3, 'A', 'B', 'C');
    
    /*
     * [실행 결과 분석]
     * 원판 1: A --> C
     * 원판 2: A --> B
     * 원판 1: C --> B
     * 원판 3: A --> C
     * 원판 1: B --> A
     * 원판 2: B --> C
     * 원판 1: A --> C
     * 
     * [이동 과정 시각화]
     * 초기 상태: A(1,2,3), B(), C()  (1이 가장 작은 원반, 3이 가장 큰 원반)
     * 
     * 1. 원판 1: A --> C: A(2,3), B(), C(1)
     * 2. 원판 2: A --> B: A(3), B(2), C(1)
     * 3. 원판 1: C --> B: A(3), B(1,2), C()
     * 4. 원판 3: A --> C: A(), B(1,2), C(3)
     * 5. 원판 1: B --> A: A(1), B(2), C(3)
     * 6. 원판 2: B --> C: A(1), B(), C(2,3)
     * 7. 원판 1: A --> C: A(), B(), C(1,2,3)
     * 
     * 최종 상태: A(), B(), C(1,2,3)
     * 
     * [시간 복잡도]
     * n개 원반을 옮기는 데 필요한 최소 이동 횟수: 2^n - 1
     * 3개 원반: 2^3 - 1 = 7번 이동
     * 4개 원반: 2^4 - 1 = 15번 이동
     * 
     * [재귀의 역할]
     * 이 문제는 재귀적 접근 없이 해결하기 매우 어렵지만,
     * 재귀를 사용하면 직관적이고 간결한 해결책을 제시할 수 있습니다.
     * 이는 복잡한 문제를 더 작은 동일한 형태의 부분 문제로 나누어 해결하는
     * 분할 정복(Divide and Conquer) 알고리즘의 좋은 예입니다.
     */
}
