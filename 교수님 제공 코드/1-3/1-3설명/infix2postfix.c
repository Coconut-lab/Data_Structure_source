// 명품 열혈 C자료구조(최영규, 생능 출판사, 2024)
// 참고파일 ch03/infix2postfix.c

//-------------------------------------------------------------
// 코드 3.7 중위 표기식 후위 표기식 변환 프로그램
//-------------------------------------------------------------
/*
 * [프로그램 설명]
 * 이 프로그램은 중위 표기식(infix notation)을 후위 표기식(postfix notation)으로 변환합니다.
 * 
 * [표기식 설명]
 * - 중위 표기식: 연산자가 피연산자 사이에 위치 (예: A + B)
 * - 후위 표기식: 연산자가 피연산자 뒤에 위치 (예: A B +)
 * 
 * [변환 알고리즘의 핵심]
 * 1. 피연산자는 즉시 출력
 * 2. 여는 괄호 '('는 스택에 push
 * 3. 닫는 괄호 ')'를 만나면 '('까지 스택에서 pop하며 출력
 * 4. 연산자는 스택 top의 연산자보다 우선순위가 높으면 push, 낮거나 같으면 pop 후 출력
 * 5. 입력이 끝나면 스택에 남은 모든 연산자를 pop하며 출력
 */

#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
typedef char Element; // 스택에는 연산자가 저장됨
#include "ArrayStack.h"

/*
 * [함수: precedence]
 * 매개변수: char op - 연산자
 * 반환값: int - 연산자의 우선순위 (숫자가 클수록 높은 우선순위)
 * 기능: 연산자의 우선순위를 반환
 */
int precedence(char op)
{
    switch (op) {
    case '(': case ')': return 0;  // 괄호는 스택 내에서 최저 우선순위
    case '+': case '-': return 1;  // 덧셈, 뺄셈은 중간 우선순위
    case '*': case '/': return 2;  // 곱셈, 나눗셈은 최고 우선순위
    }
    return -1;  // 알 수 없는 연산자
}

/*
 * [함수: infix_to_postfix]
 * 매개변수: char* expr - 변환할 중위 표기식 문자열
 * 기능: 중위 표기식을 후위 표기식으로 변환하여 출력
 */
void infix_to_postfix(char* expr)
{
    init_stack();  // 스택 초기화

    int i = 0;
    while (expr[i] != '\0') {  // 문자열 끝까지 처리
        char c = expr[i++];  // 현재 문자를 가져오고 인덱스 증가
        
        // 피연산자(숫자)인 경우: 바로 출력
        if ((c >= '0' && c <= '9')) {
            printf("%c ", c);
        }
        // 여는 괄호인 경우: 스택에 push
        else if (c == '(')
            push(c);
        // 닫는 괄호인 경우: 여는 괄호를 만날 때까지 pop하며 출력
        else if (c == ')') {
            while (is_empty() == 0) {  // 스택이 비어있지 않으면 계속
                char op = pop();
                if (op == '(') break;  // 여는 괄호를 만나면 중단 (괄호 쌍 완성)
                else printf("%c ", op);  // 다른 연산자는 출력
            }
        }
        // 연산자인 경우: 우선순위에 따라 처리
        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            // 현재 연산자보다 우선순위가 높거나 같은 연산자들을 모두 출력
            while (is_empty() == 0) {
                char op = peek();  // 스택 top의 연산자 확인
                if (precedence(c) <= precedence(op)) {  // 우선순위 비교
                    printf("%c ", op);
                    pop();  // 출력 후 pop
                }
                else break;  // 현재 연산자의 우선순위가 더 높으면 중단
            }
            push(c);  // 현재 연산자를 스택에 push
        }
    }
    
    // 스택에 남아있는 모든 연산자를 출력
    while (is_empty() == 0)
        printf("%c ", pop());
    printf("\n");
}

void main()
{
    // 테스트할 두 개의 중위 표기식
    char expr[2][80] = { "8 / 2 - 3 + (3 * 2)", "1 / 2 * 4 * (1 / 4)" };

    // 각 표기식을 후위 표기식으로 변환하여 출력
    printf("중위표기: %s ==> 후위표기:", expr[0]);
    infix_to_postfix(expr[0]);
    printf("중위표기: %s ==> 후위표기:", expr[1]);
    infix_to_postfix(expr[1]);
    
    /*
     * [실행 결과 분석]
     * 중위표기: 8 / 2 - 3 + (3 * 2) ==> 후위표기: 8 2 / 3 - 3 2 * + 
     * 중위표기: 1 / 2 * 4 * (1 / 4) ==> 후위표기: 1 2 / 4 * 1 4 / * 
     * 
     * [알고리즘 동작 예시]
     * 입력: 8 / 2 - 3 + (3 * 2)
     * 
     * 과정 (스택 상태와 출력):
     * '8': 출력 "8 "                  스택: []
     * '/': push                       스택: [/]
     * '2': 출력 "8 2 "                스택: [/]
     * '-': '/'보다 우선순위 낮음, pop  스택: []
     *      출력 "8 2 / "
     *      push                       스택: [-]
     * '3': 출력 "8 2 / 3 "            스택: [-]
     * '+': '-'보다 우선순위 낮음, pop  스택: []
     *      출력 "8 2 / 3 - "
     *      push                       스택: [+]
     * '(': push                       스택: [+, (]
     * '3': 출력 "8 2 / 3 - 3 "        스택: [+, (]
     * '*': push                       스택: [+, (, *]
     * '2': 출력 "8 2 / 3 - 3 2 "      스택: [+, (, *]
     * ')': pop & 출력 '*'             스택: [+, (]
     *      출력 "8 2 / 3 - 3 2 * "
     *      pop '('                    스택: [+]
     * 종료: pop & 출력 '+'             스택: []
     *      출력 "8 2 / 3 - 3 2 * + "
     * 
     * [후위 표기식의 장점]
     * 1. 괄호 없이도 연산 우선순위를 명확히 표현 가능
     * 2. 컴퓨터가 계산하기 쉬움 (스택 하나로 간단히 계산 가능)
     * 3. 컴파일러에서 수식 처리에 많이 활용됨
     */
}
