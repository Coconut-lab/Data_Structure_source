// 명품 열혈 C자료구조(최영규, 생능 출판사, 2024)
// 참고파일 ch03/check_matching.c

//-------------------------------------------------------------
// 코드 3.5 괄호 검사 프로그램
//-------------------------------------------------------------
/*
 * [프로그램 설명]
 * 이 프로그램은 소스 코드나 수식에서 괄호의 짝이 올바르게 매칭되는지 검사합니다.
 * 스택을 활용하여 여는 괄호는 push하고, 닫는 괄호를 만나면 pop하여 짝이 맞는지 확인합니다.
 * 
 * [괄호 검사 규칙]
 * 1. 여는 괄호와 닫는 괄호의 개수가 일치해야 함
 * 2. 닫는 괄호는 가장 최근에 열린 괄호와 짝을 이루어야 함
 * 3. 괄호 종류도 일치해야 함 (소괄호, 중괄호, 대괄호)
 */

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
typedef char Element; // 스택 요소 Element의 자료형을 char로 정의
#include "ArrayStack.h" // 스택의 ADT(데이터와 연산) 포함

/*
 * [함수: check_matching]
 * 매개변수: char expr[] - 검사할 문자열 (수식 또는 소스 코드)
 * 반환값: 정수 (0: 정상, 1~3: 오류 코드)
 * 기능: 주어진 문자열의 괄호가 올바르게 매칭되는지 검사
 */
int check_matching(char expr[])
{
    int i = 0, prev;

    init_stack();  // 스택 초기화
    
    // 문자열의 끝(널 문자)까지 검사
    while (expr[i] != '\0') {
        char ch = expr[i++];  // 현재 문자를 가져오고 인덱스 증가
        
        // 여는 괄호인 경우: 스택에 push
        if (ch == '[' || ch == '(' || ch == '{')
            push(ch);
            
        // 닫는 괄호인 경우: 매칭되는 여는 괄호가 있는지 확인
        else if (ch == ']' || ch == ')' || ch == '}') {
            if (is_empty())
                return 2;       // 오류 2: 닫는 괄호에 대응하는 여는 괄호가 없음
            
            prev = pop();  // 가장 최근에 추가된 여는 괄호를 꺼냄
            
            // 괄호 종류가 일치하는지 검사
            if ((ch == ']' && prev != '[')
                || (ch == ')' && prev != '(')
                || (ch == '}' && prev != '{'))
                return 3;       // 오류 3: 괄호 종류 불일치
        }
    }
    
    // 문자열 검사 후 스택이 비어있지 않으면 여는 괄호가 남아있음
    if (!is_empty()) return 1;  // 오류 1: 여는 괄호가 더 많음
    else return 0;              // 정상: 모든 괄호가 올바르게 매칭됨
}

/*
 * [오류 코드 설명]
 * 0: 정상 - 모든 괄호가 올바르게 매칭됨
 * 1: 여는 괄호가 더 많음 - 닫는 괄호 부족
 * 2: 닫는 괄호가 더 많음 - 여는 괄호 부족
 * 3: 괄호 종류 불일치 - 올바르지 않은 순서로 닫힘
 */

void main()
{
    // 테스트할 4개의 예제 문자열
    char expr[4][80] = {
        "{A[(i+1)]=0;}",        // 정상
        "if((i==0) && (j==0)",  // 오류 1: 닫는 괄호 부족
        "while(n<8)){n++;}",    // 오류 2: 닫는 괄호 과다
        "arr[(i+1]) = 0;" };    // 오류 3: 괄호 종류 불일치

    // 각 예제 문자열을 검사하고 결과 출력
    for (int i = 0; i < 4; i++) {
        int errCode = check_matching(expr[i]);
        if (errCode == 0) printf("%-20s -> 정상\n", expr[i]);
        else printf("%-20s -> 오류(오류%d 발생)\n", expr[i], errCode);
    }
    
    /*
     * [실행 결과 분석]
     * "{A[(i+1)]=0;}"       -> 정상: 모든 괄호가 올바르게 짝을 이룸
     * "if((i==0) && (j==0)" -> 오류(오류1 발생): 닫는 괄호가 부족함
     * "while(n<8)){n++;}"   -> 오류(오류2 발생): 닫는 괄호가 과다함
     * "arr[(i+1]) = 0;"     -> 오류(오류3 발생): 괄호 종류 불일치 ([와 ])
     * 
     * [스택을 사용하는 이유]
     * 괄호 매칭은 "가장 최근에 열린 괄호가 가장 먼저 닫혀야 한다"는 규칙을 따르는데,
     * 이는 스택의 LIFO(후입선출) 특성과 정확히 일치합니다.
     */
}
