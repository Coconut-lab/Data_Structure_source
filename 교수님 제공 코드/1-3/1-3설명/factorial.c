// 명품 열혈 C자료구조(최영규, 생능 출판사, 2024)
// 참고파일 ch03/factorial.c

#include <stdio.h>

//-------------------------------------------------------------
// 코드 3.8 반복 방식의 팩토리얼 함수
//-------------------------------------------------------------
/*
 * [함수: factorial_iter]
 * 매개변수: int n - 팩토리얼을 계산할 양의 정수
 * 반환값: int - n!의 계산 결과
 * 기능: 반복문(for)을 사용해서 팩토리얼을 계산
 * 
 * [반복 방식의 특징]
 * - 스택 사용이 필요 없음 (메모리 효율적)
 * - 구현이 직관적이고 간단함
 * - 큰 수에 대해 재귀보다 효율적일 수 있음
 */
int factorial_iter(int n)
{
    int i, result = 1;
    for (i = 1; i <= n; i++)
        result = result * i;  // 1부터 n까지 차례로 곱함
    return result;
}

//-------------------------------------------------------------
// 코드 3.9 재귀 방식의 팩토리얼 함수
//-------------------------------------------------------------
/*
 * [함수: factorial]
 * 매개변수: int n - 팩토리얼을 계산할 양의 정수
 * 반환값: int - n!의 계산 결과
 * 기능: 재귀 호출을 사용해서 팩토리얼을 계산
 * 
 * [재귀 방식의 특징]
 * - 수학적 정의와 유사하여 이해하기 쉬움: n! = n * (n-1)!
 * - 호출 스택을 사용하므로 메모리 사용량이 더 많음
 * - 큰 n에 대해 스택 오버플로우 발생 가능
 * 
 * [재귀 알고리즘의 중요 요소]
 * 1. 기저 조건(Base case): n == 1일 때 종료
 * 2. 재귀 호출: n * factorial(n-1)로 문제 크기를 줄임
 */
int factorial(int n)
{
    if (n == 1)  // 기저 조건 (Base case): 재귀 종료 조건
        return 1;
    else
        return n * factorial(n - 1);  // 재귀 호출
}

//----------------------------------------------------------------------
// 재귀 호출과 반환 과정 추적을 위한 확장 알고리즘 버전
//----------------------------------------------------------------------
/*
 * [함수: factorial_p]
 * 매개변수: int n - 팩토리얼을 계산할 양의 정수
 * 반환값: int - n!의 계산 결과
 * 기능: 재귀 호출 과정과 반환 과정을 출력하면서 팩토리얼 계산
 * 
 * [함수 추적 과정]
 * 이 함수는 재귀 호출이 어떻게 이루어지고, 어떤 순서로 반환되는지
 * 시각적으로 확인할 수 있도록 디버깅 메시지를 출력합니다.
 */
int factorial_p(int n)
{
    printf("함수 호출: factorial(%d)\n", n);	// 재귀호출 과정 확인을 위한 출력문
    int ret;
    if (n == 1) ret = 1;
    else ret = n * factorial_p(n - 1);

    // 함수의 반환 위치에 있는 문장은 역순 출력
    printf("함수 반환: factorial(%d) --> %d\n", n, ret);
    return ret;
}
//----------------------------------------------------------------------

void main()
{
    // 반복 방식과 재귀 방식 결과 비교
    printf("반복 factorial(3) = %d\n", factorial_iter(3));
    printf("재귀 factorial(3) = %d\n", factorial(3));

    // 재귀 호출 과정 추적
    factorial_p(3);
    
    /*
     * [실행 결과 분석]
     * 반복 factorial(3) = 6
     * 재귀 factorial(3) = 6
     * 
     * 함수 호출: factorial(3)
     * 함수 호출: factorial(2)
     * 함수 호출: factorial(1)
     * 함수 반환: factorial(1) --> 1
     * 함수 반환: factorial(2) --> 2
     * 함수 반환: factorial(3) --> 6
     * 
     * [재귀 호출 스택 시각화]
     * 1. factorial(3) 호출
     * 2. factorial(2) 호출 -> factorial(3) 대기
     * 3. factorial(1) 호출 -> factorial(2) 대기 -> factorial(3) 대기
     * 4. factorial(1)이 1 반환 -> factorial(2) 계속
     * 5. factorial(2)가 2 반환 -> factorial(3) 계속
     * 6. factorial(3)이 6 반환 -> 최종 결과
     * 
     * 이런 방식으로 시스템은 함수 호출 스택을 사용하여 재귀 호출을 관리합니다.
     */
}
