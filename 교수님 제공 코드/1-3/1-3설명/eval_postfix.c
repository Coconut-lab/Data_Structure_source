// 명품 열혈 C자료구조(최영규, 생능 출판사, 2024)
// 참고파일 ch03/eval_postfix.c

//-------------------------------------------------------------
// 코드 3.6 후위 표기식 계산 프로그램
//-------------------------------------------------------------
/*
 * [프로그램 설명]
 * 이 프로그램은 후위 표기식(Postfix Notation)을 계산하는 알고리즘을 구현합니다.
 * 후위 표기식은 연산자가 피연산자 뒤에 오는 표기법으로, 괄호 없이도 연산 우선순위를 명확히 표현할 수 있습니다.
 * 
 * [후위 표기식 예시]
 * 중위 표기식: (8/2)-3+(3*2)   -> 후위 표기식: 8 2 / 3 - 3 2 * +
 * 중위 표기식: (1/2)*4*(1/4)   -> 후위 표기식: 1 2 / 4 * 1 4 / *
 * 
 * [계산 원리]
 * 1. 피연산자는 스택에 push
 * 2. 연산자를 만나면 스택에서 피연산자 두 개를 pop하여 계산
 * 3. 계산 결과를 다시 스택에 push
 * 4. 최종적으로 스택에 남은 값이 계산 결과
 */

#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
typedef double Element; // 스택에서 피연산자(double)를 저장함
#include "ArrayStack.h"

/*
 * [함수: eval_postfix]
 * 매개변수: char* expr - 계산할 후위 표기식 문자열
 * 반환값: double - 계산 결과
 * 기능: 후위 표기식을 계산하여 결과 값을 반환
 */
double eval_postfix(char* expr)
{
    int i = 0;

    init_stack();  // 스택 초기화
    
    // 문자열의 끝(널 문자)까지 처리
    while (expr[i] != '\0') {
        char c = expr[i++];  // 현재 문자를 가져오고 인덱스 증가
        
        // 피연산자(숫자)인 경우: 스택에 push
        if (c >= '0' && c <= '9') {
            double num = (double)c - '0';  // 문자를 숫자로 변환 (ASCII 변환)
            push(num);
            
            /* 
             * [참고] 문자를 숫자로 변환하는 방법
             * ASCII 코드에서 '0'은 48, '1'은 49, ...
             * 따라서 '숫자 문자' - '0'을 하면 실제 숫자 값을 얻을 수 있음
             * 예: '5' - '0' = 53 - 48 = 5
             */
        }
        // 연산자인 경우: 피연산자 두 개를 pop하여 계산 후 결과를 push
        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            double val2 = pop(); // 두 번째 피연산자 (나중에 push된 값)
            double val1 = pop(); // 첫 번째 피연산자 (먼저 push된 값)
            
            /*
             * [중요] 피연산자 순서
             * 스택은 LIFO 구조이므로, 먼저 꺼낸 값(val2)이 두 번째 피연산자,
             * 나중에 꺼낸 값(val1)이 첫 번째 피연산자입니다.
             * 이는 뺄셈이나 나눗셈과 같은 비교환적 연산에서 특히 중요합니다.
             * 예: 8-3 을 계산할 때, 스택에서 3, 8 순으로 꺼내면 8-3=5가 됨
             */
            
            // 연산자에 따라 적절한 계산 수행 후 결과를 스택에 push
            switch (c) {
            case '+': push(val1 + val2); break;
            case '-': push(val1 - val2); break;
            case '*': push(val1 * val2); break;
            case '/': push(val1 / val2); break;
            }
        }
        // 공백 문자인 경우는 무시 (이 코드에서는 명시적으로 처리하지 않음)
    }
    
    // 최종 결과는 스택에 하나의 값만 남아 있어야 함
    return pop();  // 계산 결과 반환
}

void main()
{
    // 테스트할 두 개의 후위 표기식
    char expr[2][80] = { "8 2 / 3- 3 2 * +", "1 2 / 4 * 1 4 / *" };

    // 각 표기식을 계산하고 결과 출력
    printf("수식: %s = %lf\n", expr[0], eval_postfix(expr[0]));
    printf("수식: %s = %lf\n", expr[1], eval_postfix(expr[1]));
    
    /*
     * [실행 결과 분석]
     * 1. "8 2 / 3- 3 2 * +" = 7.000000
     *    중위 표기식으로는 (8/2)-3+(3*2) = 4-3+6 = 7
     * 
     * 2. "1 2 / 4 * 1 4 / *" = 0.500000
     *    중위 표기식으로는 (1/2)*4*(1/4) = 0.5*4*0.25 = 0.5
     * 
     * [후위 표기식의 장점]
     * 1. 괄호 없이도 연산 우선순위를 명확히 표현 가능
     * 2. 컴퓨터가 계산하기 쉬움 (스택 하나로 간단히 계산 가능)
     * 3. 컴파일러에서 수식 처리에 많이 활용됨
     */
}
